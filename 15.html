<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>Intermediate source sets</title>
<link rel="stylesheet" href="./golo.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="article">
<div id="header">
<h1>Intermediate source sets</h1>
<div class="details">
<span id="revnumber">version 1.0</span>
</div>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_understanding_intermediate_source_set">Understanding intermediate source set</a></li>
<li><a href="#_creating_intermediate_source_sets">Creating intermediate source sets</a></li>
<li><a href="#_the_intermediate_shared_source_problem">The intermediate shared source problem</a>
<ul class="sectlevel2">
<li><a href="#_a_horrible_workaround">A horrible workaround</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>We have seen where to put source code for <strong>all</strong> platform: in the <strong>common</strong> source set.
We have seen where to put source code for <strong>one</strong> platform: in the platform specific source set.
How do we write code that is shared for <strong>some</strong> (more than one, but not all) platforms ?</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
The way intermediate source sets currently work is very limited and leads to a sub-optimal developer experience.<br>
         A lot of their pain points are about to be relieved once Jetbrains released "hierarchical multiplatform" tooling, which is expected&#8230;&#8203; very soon!
         Maybe even tomorrow, at KotlinConf 2019.<br>
         While the concepts described in this chapter are not expected to change, their implementation most probably will in the near future.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_understanding_intermediate_source_set"><a class="anchor" href="#_understanding_intermediate_source_set"></a>Understanding intermediate source set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let&#8217;s say you are creating a library that targets every major platform Kotlin can target.
You will end up with a lot of source sets:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/source-sets-2.png" alt="source sets 2" width="371" height="1873">
</div>
</div>
<div class="paragraph">
<p>Now, when you are writing <code>expect</code> statements, you have to write 9 corresponding <code>actual</code> statements !</p>
</div>
<div class="paragraph">
<p>As you can see, we can group the various targets:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>jvmBased</code> group contains all targets that are running on JVM-like VMs: <code>android</code>, and <code>jvm</code></p>
</li>
<li>
<p>The <code>js</code> group contains the only target that runs with JavaScript: <code>js</code></p>
</li>
<li>
<p>The <code>ios</code> group contains all iOS targets: <code>iosX64</code>, <code>iosArm32</code>, and <code>iosArm64</code></p>
</li>
<li>
<p>The <code>host</code> group contains all native developer host targets: <code>linuxX64</code>, <code>macosX64</code>, <code>mingwX64</code></p>
</li>
<li>
<p>The <code>native</code> group contains all native targets: both <code>host</code> and <code>iOS</code> groups.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It is pretty easy to see that, in the vast majority of cases, the <code>actual</code> statements are going to be the same for an entire group.
It is very unlikely that an <code>actual</code> statement will vary between <code>iosArm32</code> &amp; <code>iosArm64</code>.</p>
</div>
<div class="paragraph">
<p>It would be really great if we could write these <code>actual</code> statements only once&#8230;&#8203;<br>
&#8230;&#8203;Well, of course we can! That&#8217;s what intermediate source sets are for: provide source that are common to some (not all) platforms.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/source-sets-3.png" alt="source sets 3" width="707" height="1475">
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_creating_intermediate_source_sets"><a class="anchor" href="#_creating_intermediate_source_sets"></a>Creating intermediate source sets</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The above example is an "extreme" case, where you target all platforms.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s get back to our mobile only project and create an intermediate source set for iOS.
That way, we will be able to compile for all three iOS targets with only one source set.</p>
</div>
<div class="paragraph">
<p>Creating a source set is not enough, you must link it in the hierarchy.
To configure an <code>iOSMain</code> intermediate source set, you need to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Create the <code>iOSMain</code> source set.</p>
</li>
<li>
<p>Configure the <code>iOSMain</code> source set to depend on the <code>commonMain</code> source set.</p>
</li>
<li>
<p>Configure all three platform iOS targets main source sets to depend on the <code>iOSMain</code> source set.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The same goes for the <code>iOSTest</code> source set, with this additional step:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Configure the <code>iOSTest</code> source set to depend on the <code>iOSMain</code> source set.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Here is an example for the targets the <code>iOS</code> group:</p>
</div>
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">kotlin {
    //...

    configure(listOf(iosX64(), iosArm64(), iosArm32())) { <i class="conum" data-value="1"></i><b>(1)</b>
        binaries {
            framework {
                baseName = "AddressBookCommon"
            }
        }
    }

    sourceSets {
        val commonMain by getting {
            dependencies {
                implementation(kotlin("stdlib-common"))
                implementation(coroutines("-common"))
                implementation(serialization("-common"))
                implementation(ktorClient("core"))
                implementation(ktorClient("json"))
                implementation(ktorClient("serialization"))
            }
        }
        val commonTest by getting {
            dependencies {
                implementation(kotlin("test-common"))
                implementation(kotlin("test-annotations-common"))
            }
        }

        val iosMain by creating { <i class="conum" data-value="2"></i><b>(2)</b>
            dependsOn(commonMain) <i class="conum" data-value="3"></i><b>(3)</b>

            dependencies { <i class="conum" data-value="4"></i><b>(4)</b>
                implementation(coroutines("-native"))
                implementation(serialization("-native"))
                implementation(ktorClient("core-native"))
                implementation(ktorClient("json-native"))
                implementation(ktorClient("serialization-native"))
                implementation(ktorClient("ios"))
            }
        }

        val iosTest by creating { <i class="conum" data-value="2"></i><b>(2)</b>
            dependsOn(commonTest) <i class="conum" data-value="3"></i><b>(3)</b>
            dependsOn(iosMain) <i class="conum" data-value="5"></i><b>(5)</b>
        }

        listOf("iosX64", "iosArm64", "iosArm32").forEach {
            getByName("${it}Main") { <i class="conum" data-value="6"></i><b>(6)</b>
                dependsOn(iosMain)
            }
            getByName("${it}Test") { <i class="conum" data-value="7"></i><b>(7)</b>
                dependsOn(iosTest)
            }
        }

    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Adds all three iOS targets, and configures their corresponding framework</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Creates a new source set&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>&#8230;&#8203;and configures its parent source set(s).</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Configures this source sets (and all source sets depending on it) dependencies.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The test source set must depend on its main counterpart.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Configures all iOS platforms main source sets to depend on <code>iosMain</code></td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Configures all iOS platforms test source sets to depend on <code>iosTest</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We already have the <code>src/iosMain</code> and <code>src/iOSTest</code> directories in our structure, but while they used to reflect the <code>iosX64</code> target, they now represent an intermediate source set.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
If you added the <code>packForXcode</code> custom task from chapter 3, you need to modify the target name (the argument to the <code>getByName</code> method) from <code>"ios"</code> to <code>"iosX64"</code>.
         We will see in the next chapter how to pack for all iOS targets.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There you are, you did not change your source structure, but you are now compiling for all three iOS targets!</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_intermediate_shared_source_problem"><a class="anchor" href="#_the_intermediate_shared_source_problem"></a>The intermediate shared source problem</h2>
<div class="sectionbody">
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Once again, this is supposed to be fixed with the "hierarchical multiplatform" feature that should be released very soon.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Open the <code>dispatcherIos.kt</code> source file in the <code>iosMain</code> source set.
The IDE now shows an error.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/res/15-1.png" alt="source errors" width="700"></span></p>
</div>
<div class="paragraph">
<p>Don&#8217;t worry, nothing&#8217;s actually broken&#8230;&#8203;
In fact, everything still compiles and works fine.
It&#8217;s only the IDE that fails to recognize this as correct code.</p>
</div>
<div class="paragraph">
<p>This is because <strong>an intermediate source set does not have an associated platform</strong>.
In fact, the compilers themselves do not care about the directory structure, they just compile the files in the directories that the gradle plugin tells them to look for sources.<br>
The IDE, on the other hand, associates the platform SDK and standard library to each platform source set, but cannot know which platform to associate to an intermediate source set.</p>
</div>
<div class="paragraph">
<p>This is even more complex: there is no platform to associate to our <code>iOS</code> intermediate source set.
There is no <code>iOS</code> platform.<br>
There are three platforms that could be associated to this source set: <code>iosX64</code>, <code>iosArm64</code>, and <code>iosArm32</code>.
Granted, they are very close, but to the IDE and the native compiler, they are totally different targets.
What the IDE should associate to this source set is the <em>intersection</em> of the three platforms.</p>
</div>
<div class="paragraph">
<p>At the time of writing, <strong>the IDE wrongly associates the <em>common</em> target to all intermediate source sets</strong>.<br>
This means that, while the iOS specific code do compile and behaves as expected, the IDE shows errors because it does not see a <code>dispatch_async</code> function in the common SDK.</p>
</div>
<div class="sect2">
<h3 id="_a_horrible_workaround"><a class="anchor" href="#_a_horrible_workaround"></a>A horrible workaround</h3>
<div class="paragraph">
<p>There is a workaround, but it is quite a horrible hack, and renders the developer experience a bit difficult.
It consists in maintaining two different gradle configurations: one to develop, and one to deploy.</p>
</div>
<div class="paragraph">
<p>First, create a <code>gradle.properties</code> file at the root of your project.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/res/15-2.png" alt="new gradle.properties file" width="400"></span></p>
</div>
<div class="paragraph">
<p>Add this line to the file:</p>
</div>
<div class="listingblock">
<div class="title">gradle.properties</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="properties" class="language-properties hljs">iosDevHack = true</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The <code>gradle.properties</code> file is usually not commited, and used to set developer specific options.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here is the updated <code>build.gradle.kts</code> with the hack:</p>
</div>
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val iosDevHack: String? by project
val iosDevHackEnabled = iosDevHack == "true" <i class="conum" data-value="1"></i><b>(1)</b>

kotlin {
    //...

    val iosTargets = <i class="conum" data-value="2"></i><b>(2)</b>
            if (iosDevHackEnabled) listOf(iosX64("ios"))
            else listOf(iosX64(), iosArm64(), iosArm32())
    configure(iosTargets) {
        binaries {
            framework {
                baseName = "AddressBookCommon"
            }
        }
    }

    sourceSets {
        val commonMain by getting {
            dependencies {
                implementation(kotlin("stdlib-common"))
                implementation(coroutines("-common"))
                implementation(serialization("-common"))
                implementation(ktorClient("core"))
                implementation(ktorClient("json"))
                implementation(ktorClient("serialization"))
            }
        }
        val commonTest by getting {
            dependencies {
                implementation(kotlin("test-common"))
                implementation(kotlin("test-annotations-common"))
            }
        }

        if (!iosDevHackEnabled) { <i class="conum" data-value="3"></i><b>(3)</b>
            create("iosMain").apply {
                dependsOn(commonMain)
            }
        }

        val iosMain by getting { <i class="conum" data-value="4"></i><b>(4)</b>
            dependencies {
                implementation(coroutines("-native"))
                implementation(serialization("-native"))
                implementation(ktorClient("core-native"))
                implementation(ktorClient("json-native"))
                implementation(ktorClient("serialization-native"))
                implementation(ktorClient("ios"))
            }
        }

        if (!iosDevHackEnabled) { <i class="conum" data-value="3"></i><b>(3)</b>
            create("iosTest").apply {
                dependsOn(commonTest)
                dependsOn(iosMain)
            }
        }

        val iosTest by getting {} <i class="conum" data-value="4"></i><b>(4)</b>

        if (!iosDevHackEnabled) { <i class="conum" data-value="5"></i><b>(5)</b>
            listOf("iosX64", "iosArm64", "iosArm32").forEach {
                getByName("${it}Main") {
                    dependsOn(iosMain)
                }
                getByName("${it}Test") {
                    dependsOn(iosTest)
                }
            }
        }

    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Get the <code>iosDevHack</code> property value.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Configures either only one <code>iOS</code> target, or three.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Create and configure the intermediate source set if the hack is not enabled.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Configuring the source set, it could be intermediate or not.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>If the hack is not enabled, configure each target&#8217;s source set to depend on the intermediate source set.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>And there you have it, the <code>iosMain</code> source set is either:
- a target&#8217;s platform source set, or
- an intermediate source set.</p>
</div>
<div class="paragraph">
<p>Not that we have seen how to target all three iOS targets, let&#8217;s see how to deploy for the three targets at once.</p>
</div>
</div>
</div>
</div>
</div>
<link rel="stylesheet" href="highlightjs/styles/idea.min.css">
<script src="highlightjs/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>