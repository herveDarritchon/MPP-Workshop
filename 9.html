<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>Address book - Going further with the MVP pattern</title>
<link rel="stylesheet" href="./golo.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="article">
<div id="header">
<h1>Address book - Going further with the MVP pattern</h1>
<div class="details">
<span id="revnumber">version 1.0</span>
</div>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_what_is_the_mvp_pattern">What is the MVP pattern ?</a></li>
<li><a href="#_implementing_the_mvp_pattern">Implementing the MVP pattern</a>
<ul class="sectlevel2">
<li><a href="#_architecture_for_the_mvp_pattern">Architecture for the MVP pattern</a></li>
<li><a href="#_coroutines_contexts_definition">Coroutines contexts definition</a></li>
<li><a href="#_use_case_1_retrieving_a_list_of_contacts">Use case 1: retrieving a list of contacts</a></li>
<li><a href="#_use_case_2_getting_the_details_of_a_contact">Use case 2: getting the details of a contact</a></li>
<li><a href="#_use_case_3_creating_or_updating_a_contact">Use case 3: creating or updating a contact</a></li>
</ul>
</li>
<li><a href="#_defining_some_helpers">Defining some helpers</a>
<ul class="sectlevel2">
<li><a href="#_a_little_bit_of_manual_dependency_injection">A little bit of manual Dependency Injection</a></li>
</ul>
</li>
<li><a href="#_building_and_publishing_your_multi_platform_library">Building and publishing your multi-platform library</a></li>
<li><a href="#_whats_next">What&#8217;s next ?</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Do you remember that we are working on a Kotlin multi-platform project ? Right!</p>
</div>
<div class="paragraph">
<p>By now, we should be able to use our business logic on every targeted platforms, and make some HTTP calls to render our data.
Not so fast! Before that, we will add some more logic in ou Kotlin multi-platform library, with the <em>MVP pattern</em>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_is_the_mvp_pattern"><a class="anchor" href="#_what_is_the_mvp_pattern"></a>What is the MVP pattern ?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>M</strong>odel-<strong>V</strong>iew-<strong>P</strong>resenter is a design pattern that help you decouple the business logic from the view of your application.
This can be represented by the following schema:</p>
</div>
<table class="tableblock frame-none grid-none stretch">
<colgroup>
<col style="width: 40%;">
<col style="width: 60%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><span class="image"><img src="images/res/mvp.png" alt="mvp pattern" width="250"></span></p></td>
<td class="tableblock halign-left valign-middle"><div class="content"><div class="paragraph">
<p>The <strong>Model</strong> is responsible for carrying the the data model, and how the data are manipulated/read/stored.</p>
</div>
<div class="paragraph">
<p>The <strong>Presenter</strong> is responsible to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>access the data from the Model or update them.</p>
</li>
<li>
<p>serve the data to the View (generally the UI), and accept interactions from the View</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <strong>View</strong> is an interface that needs to be implemented by the UI classes, that interact with the Presenter to update or get new data.</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Well, we can also implement this pattern in our Kotlin multi-platform library to maximize code sharing in our project.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementing_the_mvp_pattern"><a class="anchor" href="#_implementing_the_mvp_pattern"></a>Implementing the MVP pattern</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let&#8217;s assume that our different applications would have a <em>Master/Detail</em> flow.
The master view would show us a list of contacts, and by clicking on a contact, we will display its details on a new view.</p>
</div>
<div class="paragraph">
<p>This gives us two use cases to implement; One where we will retrieve the list of contacts from the backend API and display it on the main view.
And one where we will retrieve a contact with its details from the backend API, according to its <code>id</code>, and display it on another view.</p>
</div>
<div class="paragraph">
<p>Don&#8217;t forget that we also have to provide a view to create or update an existing contact, and then send the creation/modification to the backend API.
This is our third use case.</p>
</div>
<div class="sect2">
<h3 id="_architecture_for_the_mvp_pattern"><a class="anchor" href="#_architecture_for_the_mvp_pattern"></a>Architecture for the MVP pattern</h3>
<div class="paragraph">
<p>Before we implement our different use cases, we have to take a step back, and prepare the architecture of our MVP implementation.
Indeed, without spoiling, we can tell that our different presenters will certainly have the same shape.</p>
</div>
<div class="paragraph">
<p>For example, they all have to attach the view at their initialization and detach the view when this one will be destroyed.
Also, they all have to call the backend API in the background, and then update the UI in the main thread of the app.
This is where the coroutines step inside our scope.
In the same way that a presenter needs to be detached from the view while its destroyed,
the coroutine jobs also needs to be cancelled.</p>
</div>
<div class="paragraph">
<p>That is why we need to define some architectural classes, to make our code clearer and robust.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s create a new package <code>presentation</code> and a Kotlin source file <code>base.kt</code>, still in <code>commonMain/kotlin</code>:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/res/9-1.png" alt="source directory structure" width="300"></span></p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<table class="tableblock frame-none grid-none stretch">
<colgroup>
<col style="width: 40%;">
<col style="width: 60%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="image"><img src="images/res/9-2.png" alt="new directory"></span></p></td>
<td class="tableblock halign-left valign-middle"><div class="content"><div class="paragraph">
<p>To create a package aside of an existing one, you need to create with its full path</p>
</div></div></td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>First of all we will create a <code>CoroutineScope</code> that will be carrying our <code>CoroutineContext</code> and the <code>Job</code> to run.
.base.kt</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Job
import kotlin.coroutines.CoroutineContext

class PresenterCoroutineScope(
    context: CoroutineContext <i class="conum" data-value="1"></i><b>(1)</b>
) : CoroutineScope { <i class="conum" data-value="2"></i><b>(2)</b>

    private var cancellableJob = Job() <i class="conum" data-value="3"></i><b>(3)</b>
    override val coroutineContext: CoroutineContext = context + cancellableJob <i class="conum" data-value="4"></i><b>(4)</b>

    fun viewDetached() { <i class="conum" data-value="5"></i><b>(5)</b>
        cancellableJob.cancel()
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Passes a <code>CoroutineContext</code> as parameter of the constructor (either background or UI context).</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Extends the <code>CoroutineScope</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Creates a Job, that will be responsible of the execution code, and is cancellable at any time.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><em>Overrides</em> the <code>CoroutineContext</code> by combining the current context and the cancellable job.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>If a view is detached from the presenter, call this to cancel the job, and avoid leaks.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now we can create the base class for any presenter of our project.</p>
</div>
<div class="listingblock">
<div class="title">base.kt</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">abstract class BasePresenter&lt;T&gt;(private val coroutineContext: CoroutineContext) { <i class="conum" data-value="1"></i><b>(1)</b>
    protected var view: T? = null; private set <i class="conum" data-value="2"></i><b>(2)</b>
    protected lateinit var scope: PresenterCoroutineScope <i class="conum" data-value="3"></i><b>(3)</b>

    @JsName("attachView")
    fun attachView(view: T) { <i class="conum" data-value="4"></i><b>(4)</b>
        this.view = view
        scope = PresenterCoroutineScope(coroutineContext)
        onViewAttached(view)
    }

    protected open fun onViewAttached(view: T) {} <i class="conum" data-value="5"></i><b>(5)</b>

    @JsName("detachView")
    fun detachView() { <i class="conum" data-value="6"></i><b>(6)</b>
        view = null
        scope.viewDetached()
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>T</code> represents the type of the view that is bind to the presenter</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Declares the view bind to the presenter. This will be used to send data to the view when the presenter needs to send update to the UI.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Declares the <code>CoroutineScope</code> that will manage code execution in the background (calling the backend API for example)</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Uses this to attach the view to the presenter and create the <code>CoroutineScope</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>This function will be called while attaching the view to the presenter, we could override it to put some business logic here.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Uses this when you do not need the view anymore, avoiding leaks in your application.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
We use the <code>@JsName</code> annotation to avoid that <em>Kotlin/JS</em> compiler mangles the functions' names
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For each of the use cases, we have to define two interfaces.
Those interfaces will be the contract that the view and the presenter have to respect.
Also, we will create an implementation for each presenters' contract that will work with the backend API and interact with the view.</p>
</div>
</div>
<div class="sect2">
<h3 id="_coroutines_contexts_definition"><a class="anchor" href="#_coroutines_contexts_definition"></a>Coroutines contexts definition</h3>
<div class="paragraph">
<p>Previously, we have defined that our presenter will execute some business logic into a given <code>CoroutineScope</code>, to avoid blocking the main thread.
Thus, we should define a coroutine context on which our background processes will be executed, but we should also provide a coroutine context that will allow the presenter to interact with the view.
That is why we will provide coroutine dispatchers, as they determine what thread the corresponding coroutine uses for its execution.</p>
</div>
<div class="paragraph">
<p>In <code>commonMain/kotlin</code>, create a new Kotlin source file <code>dispatchers.kt</code>:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/res/9-3.png" alt="source directory structure" width="300"></span></p>
</div>
<div class="paragraph">
<p>In this source file, we will put two dispatchers, one for background jobs (<code>ApplicationDispatcher</code>) and one for UI interactions (<code>UIDispatcher</code>).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You may know that coroutines does not work in the same way depending on the platform we are running.
For example, on <strong><em>iOS</em></strong> every coroutines are running on the main thread (even, this would change in future version).</p>
</div>
<div class="paragraph">
<p>However, for that reason our dispatchers will be defined as <code>expect</code>ed properties, and must be explicitly declared for each platforms.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Open the <code>dispatchers.kt</code> file and add the following lines:</p>
</div>
<div class="listingblock">
<div class="title">dispatchers.kt</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import kotlin.coroutines.CoroutineContext

internal expect val ApplicationDispatcher: CoroutineContext <i class="conum" data-value="1"></i><b>(1)</b>
internal expect val UIDispatcher: CoroutineContext <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>To execute code in the background of the application.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>To execute code in the foreground of the application and interact with the UI.</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_actual_implementation_for_the_dispatchers"><a class="anchor" href="#_actual_implementation_for_the_dispatchers"></a><code>actual</code> implementation for the dispatchers</h4>
<div class="paragraph">
<p>We have defined an <code>expect</code> function in our code,
thus we must define an <code>actual</code> behaviors foreach targeted platforms to be able to compile our project.</p>
</div>
<div class="paragraph">
<p>For each targets, create a kotlin source file named <code>[dispatchers][platform].kt</code>, and add the right implementation for <code>apiBaseUrl()</code>.</p>
</div>
<div class="listingblock">
<div class="title">androidMain &gt; kotlin &gt; com.mybusiness/dispatchersAndroid.kt</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">internal actual val ApplicationDispatcher: CoroutineContext = Dispatchers.Default <i class="conum" data-value="1"></i><b>(1)</b>
internal actual val UIDispatcher: CoroutineContext = Dispatchers.Main <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Uses a shared pool of threads</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Uses the main thread</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">iosMain &gt; kotlin &gt; com.mybusiness/dispatchersIos.kt</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.Runnable
import platform.darwin.dispatch_async
import platform.darwin.dispatch_get_main_queue
import kotlin.coroutines.CoroutineContext

internal actual val ApplicationDispatcher: CoroutineContext = IosMainDispatcher() <i class="conum" data-value="1"></i><b>(1)</b>
internal actual val UIDispatcher: CoroutineContext = IosMainDispatcher() <i class="conum" data-value="1"></i><b>(1)</b>

internal class IosMainDispatcher() : CoroutineDispatcher() {
    override fun dispatch(context: CoroutineContext, block: Runnable) {
        dispatch_async(dispatch_get_main_queue()) { block.run() }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>As told before, for now the coroutines can only work on the main thread for Kotlin/Native,
thus the dispatchers for <strong><em>iOS</em></strong> will run on the same thread.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">jsMain &gt; kotlin &gt; com.mybusiness/dispatchersJs.kt</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">internal actual val ApplicationDispatcher: CoroutineContext = Dispatchers.Default <i class="conum" data-value="1"></i><b>(1)</b>
internal actual val UIDispatcher: CoroutineContext = Dispatchers.Main <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Uses a shared pool of threads</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Uses the main thread</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>That&#8217;s it. You are all set up to implement the MVP pattern for our three use cases.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_use_case_1_retrieving_a_list_of_contacts"><a class="anchor" href="#_use_case_1_retrieving_a_list_of_contacts"></a>Use case 1: retrieving a list of contacts</h3>
<div class="paragraph">
<p>In the <code>presentation</code> package, create a new Kotlin source file <code>ContactList.kt</code>, still in the <code>commonMain</code> module:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/res/9-4.png" alt="source directory structure" width="300"></span></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The contract</p>
<div class="listingblock">
<div class="title">ContactList.kt</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class ContactList {
    interface Presenter
    interface View {
        @JsName("displayContactList")
        fun displayContactList(contactList: List&lt;Contact&gt;) <i class="conum" data-value="1"></i><b>(1)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Function called by the presenter when the data are ready to be displayed.</td>
</tr>
</table>
</div>
</li>
<li>
<p>The presenter implementation</p>
<div class="listingblock">
<div class="title">ContactList.kt</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class ContactListPresenter(
    private val contactApi: ContactApi, <i class="conum" data-value="1"></i><b>(1)</b>
    coroutineContext: CoroutineContext = ApplicationDispatcher <i class="conum" data-value="2"></i><b>(2)</b>
) : ContactList.Presenter, BasePresenter&lt;ContactList.View&gt;(coroutineContext) { <i class="conum" data-value="3"></i><b>(3)</b>
    override fun onViewAttached(view: ContactList.View) {
        scope.launch { <i class="conum" data-value="4"></i><b>(4)</b>
            val contactList = contactApi.getAllContacts()
            withContext(UIDispatcher) { <i class="conum" data-value="5"></i><b>(5)</b>
                view?.displayContactList(contactList) <i class="conum" data-value="6"></i><b>(6)</b>
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>To reach the backend API we need a reference of a <code>ContactApi</code> instance.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>As the <code>ContactApi</code> functions are suspendable, we need a coroutine context to execute them.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We implement <code>ContactList.Presenter</code> to respect the contract, and extend <code>BasePresenter</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Launches a coroutine on <code>BasePresenter.scope</code> which runs on the coroutine context <code>ApplicationDispatcher</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>After executing the API call we use another coroutine context in which we can interact with the UI, using the result of the API call.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Updates the UI.</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_use_case_2_getting_the_details_of_a_contact"><a class="anchor" href="#_use_case_2_getting_the_details_of_a_contact"></a>Use case 2: getting the details of a contact</h3>
<div class="paragraph">
<p>In the <code>presentation</code> package, create a new Kotlin source file <code>ContactDetail.kt</code>, still in the <code>commonMain</code> module:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/res/9-5.png" alt="source directory structure" width="300"></span></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The contract</p>
<div class="listingblock">
<div class="title">ContactDetail.kt</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class ContactDetail {
    interface Presenter {
        @JsName("getContact")
        fun getContact(contactId: String) <i class="conum" data-value="1"></i><b>(1)</b>
    }
    interface View {
        @JsName("displayContact")
        fun displayContact(contact: Contact) <i class="conum" data-value="2"></i><b>(2)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Function called by the view to retrieve all the details of a contact, giving its <code>id</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Function called by the presenter when the data are ready to be displayed.</td>
</tr>
</table>
</div>
</li>
<li>
<p>The presenter implementation</p>
<div class="listingblock">
<div class="title">ContactDetail.kt</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class ContactDetailPresenter(
    private val contactApi: ContactApi, <i class="conum" data-value="1"></i><b>(1)</b>
    coroutineContext: CoroutineContext = ApplicationDispatcher <i class="conum" data-value="2"></i><b>(2)</b>
) : ContactDetail.Presenter, BasePresenter&lt;ContactDetail.View&gt;(coroutineContext) { <i class="conum" data-value="3"></i><b>(3)</b>
    override fun getContact(contactId: String) {
        scope.launch { <i class="conum" data-value="4"></i><b>(4)</b>
            val contact = contactApi.getContactById(contactId)
            withContext(UIDispatcher) { <i class="conum" data-value="5"></i><b>(5)</b>
                view?.displayContact(contact) <i class="conum" data-value="6"></i><b>(6)</b>
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>To reach the backend API we need a reference of a <code>ContactApi</code> instance.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>As the <code>ContactApi</code> functions are suspendable, we need a coroutine context to execute them.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We implement <code>ContactList.Presenter</code> to respect the contract, and extend <code>BasePresenter</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Launches a coroutine on <code>BasePresenter.scope</code> which runs on the coroutine context <code>ApplicationDispatcher</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>After executing the API call we use another coroutine context in which we can interact with the UI, using the result of the API call.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Updates the UI.</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_use_case_3_creating_or_updating_a_contact"><a class="anchor" href="#_use_case_3_creating_or_updating_a_contact"></a>Use case 3: creating or updating a contact</h3>
<div class="paragraph">
<p>In the <code>presentation</code> package, create a new Kotlin source file <code>ContactCreateUpdate.kt</code>, still in the <code>commonMain</code> module:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/res/9-6.png" alt="source directory structure" width="300"></span></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The contract</p>
<div class="listingblock">
<div class="title">ContactCreateUpdate.kt</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class ContactCreationUpdate {
    interface Presenter {
        @JsName("updateOrCreateContact")
        fun updateOrCreateContact(contact: Contact) <i class="conum" data-value="1"></i><b>(1)</b>
    }
    interface View {
        @JsName("updateOrCreationSucceed")
        fun updateOrCreationSucceed() <i class="conum" data-value="2"></i><b>(2)</b>
        @JsName("updateOrCreationFails")
        fun updateOrCreationFails() <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Function called by the view to create or update a contact on the backend.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Function called by the presenter when the data are ready to be displayed.</td>
</tr>
</table>
</div>
</li>
<li>
<p>The presenter implementation</p>
<div class="listingblock">
<div class="title">ContactCreateUpdate.kt</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class ContactCreationUpdatePresenter(
    private val contactApi: ContactApi, <i class="conum" data-value="1"></i><b>(1)</b>
    coroutineContext: CoroutineContext = ApplicationDispatcher <i class="conum" data-value="2"></i><b>(2)</b>
) : ContactCreationUpdate.Presenter, BasePresenter&lt;ContactCreationUpdate.View&gt;(coroutineContext) { <i class="conum" data-value="3"></i><b>(3)</b>
    override fun updateOrCreateContact(contact: Contact) {
        scope.launch { <i class="conum" data-value="4"></i><b>(4)</b>
            try {
                if (contact.id == "-1") contactApi.putContact(contact) <i class="conum" data-value="5"></i><b>(5)</b>
                else contactApi.postContact(contact) <i class="conum" data-value="5"></i><b>(5)</b>

                withContext(UIDispatcher) { view?.updateOrCreationSucceed() } <i class="conum" data-value="6"></i><b>(6)</b>
            } catch (e: Exception) {
                withContext(UIDispatcher) { view?.updateOrCreationFails() } <i class="conum" data-value="6"></i><b>(6)</b>
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>To reach the backend API we need a reference of a <code>ContactApi</code> instance.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>As the <code>ContactApi</code> functions are suspendable, we need a coroutine context to execute them.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We implement <code>ContactList.Presenter</code> to respect the contract, and extend <code>BasePresenter</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Launches a coroutine on <code>BasePresenter.scope</code> which runs on the coroutine context <code>ApplicationDispatcher</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Runs the API call. Depending on the contract <code>id</code>, either we create a contact, either we update a contact.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Depending on if the API call gone well, or if there has been an exception, we use a coroutine context on the UI dispatcher, and send an update to the UI.</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_defining_some_helpers"><a class="anchor" href="#_defining_some_helpers"></a>Defining some helpers</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_a_little_bit_of_manual_dependency_injection"><a class="anchor" href="#_a_little_bit_of_manual_dependency_injection"></a>A little bit of manual Dependency Injection</h3>
<div class="paragraph">
<p>To avoid creating our different objects manually, let&#8217;s provide a singleton object, that will serve instances through regular functions.</p>
</div>
<div class="paragraph">
<p>Create a new package <code>di</code> and a Kotlin source file <code>CommonInjector.kt</code>:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/res/9-7.png" alt="source directory structure" width="300"></span></p>
</div>
<div class="listingblock">
<div class="title">CommonInjector.kt</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ThreadLocal <i class="conum" data-value="1"></i><b>(1)</b>
object CommonInjector {
    //    API
    private val api: ContactApi by lazy { <i class="conum" data-value="2"></i><b>(2)</b>
        ContactApi()
    }
    //    Presenters
    fun contactListPresenter() = ContactListPresenter(api) <i class="conum" data-value="3"></i><b>(3)</b>
    fun contactDetailPresenter() = ContactDetailPresenter(api) <i class="conum" data-value="3"></i><b>(3)</b>
    fun contactCreationUpdatePresenter() = ContactCreationUpdatePresenter(api) <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Every thread gets its own instance of <code>CommonInjector</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Lazily instantiate a <code>ContactApi</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Instantiating presenters with the <code>ContactApi</code> instance.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_building_and_publishing_your_multi_platform_library"><a class="anchor" href="#_building_and_publishing_your_multi_platform_library"></a>Building and publishing your multi-platform library</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Before going further, we need to prepare our multi-platform library by building and publishing it with Gradle.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For the <code>JVM</code></p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In your Gradle build file <code>build.gradle.kts</code> we have put the plugin <code>maven-publish</code></p>
</div>
<div class="listingblock">
<div class="title">build.gradle.kts &gt; plugin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">plugins {
    //...
    `maven-publish`
}</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In your Gradle script change your version from <code>1.0.0-SNAPSHOT</code> to <code>1.0.0</code>.</p>
</div>
<div class="paragraph">
<p>In the Gradle pane, you should see a new task group, named <code>publishing</code> (hit the refresh button if you don&#8217;t).</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/res/9-8.png" alt="gradle publishing" width="250"></span></p>
</div>
<div class="paragraph">
<p>Then, in <code>Tasks</code> &gt; <code>publishing</code>, double click on <code>publishToMavenLocal</code> to run this Gradle task.</p>
</div>
</li>
<li>
<p>For all the other platforms</p>
<div class="paragraph">
<p>As told before, we won&#8217;t cover library publication for <strong><em>Native</em></strong> and <strong><em>JavaScript</em></strong> is this workshop.
So, to use our Kotlin multi-platform library on those platform we will generate and import them manually.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>To build your Kotlin multi-platform library go to the Gradle pane and run the task <code>build</code> in the <code>build</code> group.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_whats_next"><a class="anchor" href="#_whats_next"></a>What&#8217;s next ?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now your Kotlin multi-platform library is all set up.
In the next chapters we will see how to enjoy our common code across the different platforms that we are targeting.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s start with <strong><em>Android</em></strong>!</p>
</div>
</div>
</div>
</div>
<link rel="stylesheet" href="highlightjs/styles/idea.min.css">
<script src="highlightjs/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>